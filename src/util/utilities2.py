# -*- coding: utf-8 -*-#coding: utf-8from datetime import datetime, timedelta, dateimport time#from dateutil import rruleimport configparserimport refrom unicodedata import normalizeimport osimport zipfileimport urllib.requestimport shutilimport globimport csvimport base64import seleniumfrom selenium import webdriverimport ftplibfrom selenium.webdriver.common.action_chains import ActionChainsfrom selenium.common.exceptions import NoSuchElementExceptionfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWait # available since 2.4.0from selenium.webdriver.support import expected_conditions as EC # available since 2.26.0#from selenium.webdriver import ActionChainsfrom PIL import Imagefrom PIL import ImageFontfrom PIL import ImageDrawimport unicodedataimport numpy as npimport cv2import sys# sys.path.append("../Adapter/")sys.path.append("..")import timeimport loggingimport logging.configimport osfrom PIL import ImageFontimport img2pdffrom PIL import Imageimport osfrom anticaptchaofficial.imagecaptcha import *from anticaptchaofficial.recaptchav2proxyless import *from threading import Threadclass Utilities():    def __init__(self,nome_robo_exec,robo_pid_exec,test_config_dir_direto=True):        self.test_config_dir_direto=test_config_dir_direto        print(f'self.test_config_dir_direto={self.test_config_dir_direto}')        print(f'\n\n\n--------------\n---------\n----\nnome_robo_exec {nome_robo_exec}, robo_pid_exec {robo_pid_exec}')        robo_nome = self.pega_nome_robo(nome_robo_exec)        robo_pid = robo_pid_exec        robo_codigo = '{}_{}'.format(robo_nome, robo_pid)        print('AA01')        config = self.get_config()        print('AA02')        ### Cria logger        log_config = config['log']['log_config']        print('AA03')        log_file = config['log']['log_file']        print('AA04')        log_dir = config['log']['log_dir']                self.path_font=config['utilidades']['path_font']        self.path_tmp=config['utilidades']['path_tmp']        self.font_ttf=config['utilidades']['font_ttf']                print('AA05')        logging.config.fileConfig(log_config)        print('AA06')        self.logger = logging.getLogger('robos.{}'.format(robo_codigo))        print('AA07')        self.duplica_log_robo(logging,self.logger,log_dir,robo_nome)        print('AA08')        # self.sobrescrever_arquivo(log_dir + robo_nome + '.pid', '{}'.format(robo_pid))        print('\n\n\n ------------------------- \n')        print('AA09')        # self.logger.info('| ------------------------- |')        self.logger.info(f' | -- INICIALIZADO utilities2 ! -- {robo_codigo} | ')        # self.logger.info('| ------------------------- |\n')        print(' ------------------------- \n\n\n')        print('AA10')        time.sleep(1)    def create_robo_header(self, robo_codigo, robo_descricao):        print('\n\n')        self.logger.info('******************************************************************')        # self.logger.info('*')        self.logger.info('*              Robôs - Copyright (c) 2019')        # self.logger.info('*')        self.logger.info('******************************************************************')        # self.logger.info('*')        self.logger.info('*   Robô:   ' + robo_codigo)        self.logger.info('*  <|º_º|>  ' + robo_descricao )        # self.logger.info('*')        self.logger.info('******************************************************************\n')        print('\n\n')    def create_robo_footer(self, status, inicio_execucao, fim_execucao):        print('\n\n')        self.logger.info('******************************************************************')        #self.logger.info('*')        self.logger.info('* Status:  ' + status)        self.logger.info('* Duração: ' + self.convert_seconds(fim_execucao - inicio_execucao))        #self.logger.info('*')        self.logger.info('******************************************************************\n\n')    def get_config(self):        config = configparser.ConfigParser()        print('config001')        print(f'config self.test_config_dir_direto={self.test_config_dir_direto}')        if self.test_config_dir_direto == False:            try:                print('config004')                config.read('/var/robo/ROBOS2/Adapter/config/config/config.ini', encoding='utf-8')                print("Configurações config utf8 carregadas com sucesso! 2")            except:                print('config005')                config.read('/var/robo/ROBOS2/Adapter/config/config/config.ini')                print("Configurações sem utf config carregadas com sucesso! 3")        else:            try:                print('config002')                config.read('config/config.ini', encoding='utf-8')                print("Configurações config utf8 carregadas com sucesso! 1")            except:                print('config005')                config.read('config/config.ini')                print("Configurações sem utf config carregadas com sucesso! 3")                print('config006')        print('config007')        return config    def obter_data_atual_sem_horas(self, mask):        now = date.today()        current_date = datetime.strptime(str(now), mask).date()        return current_date    def obter_data_atual_com_horas(self, mask):        now = date.today()        current_date = datetime.strftime(now, mask)        return current_date    def data_hora_brasil(self):        return time.strftime("%d/%m/%Y - %H:%M:%S")    def data_hora_americano(self):        return time.strftime("%Y/%m/%d - %H:%M:%S")    ''' Método utilizado para determinar a data limite de retenção '''    def obter_data_limite_retencao(self, data):        # Formata data        nova_data = datetime.strptime(data, "%d/%m/%Y")        holidays = [datetime.strptime('07/09/2018', "%d/%m/%Y"),                    datetime.strptime('12/10/2018', "%d/%m/%Y"),                    datetime.strptime('02/11/2018', "%d/%m/%Y"),                    datetime.strptime('15/11/2018', "%d/%m/%Y"),                    datetime.strptime('25/12/2018', "%d/%m/%Y")]        # Create a rule to recur every weekday starting today        # r = rrule.rrule(rrule.DAILY,        #                 byweekday=[rrule.MO, rrule.TU, rrule.WE, rrule.TH, rrule.FR],        #                 dtstart=nova_data)        # Create a rruleset        # rs = rrule.rruleset()        # Attach our rrule to it        # rs.rrule(r)        rs=''        # Add holidays as exclusion days        for exdate in holidays:            rs.exdate(exdate)        nova_data = rs[5]        return datetime.strftime(nova_data, "%d/%m/%Y")    def convert_seconds(self, seconds):        seconds = int(seconds)        minutes, seconds = divmod(seconds, 60)        hours, minutes = divmod(minutes, 60)        periods = [('hours', hours), ('minutes', minutes), ('seconds', seconds)]        time_string = ', '.join('{} {}'.format(value, name)                                for name, value in periods                                if value)        return time_string    def convert_millis(self, millis):        millis = int(millis)        seconds=(millis/1000)%60        seconds = int(seconds)        minutes=(millis/(1000*60))%60        minutes = int(minutes)        hours=(millis/(1000*60*60))%24        return "%d:%d:%d" % (hours, minutes, seconds)    def recupera_nome_mes(self, mes):        meses = ["Unknown",                 "JANEIRO",                 "FEVEREIRO",                 "MARÇO",                 "APRIL",                 "MAIO",                 "JUNHO",                 "JULHO",                 "AGOSTO",                 "SETEMBRO",                 "OUTUBRO",                 "NOVEMBRO",                 "DEZEMBRO"]        return meses[int(mes)]    def retorna_primeiro_dia_semana(self, mask):        day = time.strftime(mask)        dt = datetime.strptime(day, mask)        start = dt - timedelta(days=dt.weekday())        return start.strftime(mask)    def retorna_ultimo_dia_semana(self, mask):        day = time.strftime(mask)        dt = datetime.strptime(day, mask)        start = dt - timedelta(days=dt.weekday())        end = start + timedelta(days=4)        return end.strftime(mask)    def ler_arquivo_para_lista(self, filename):        f = open(filename)        lines = f.read().splitlines()        print(f'lendo lines={lines}')        f.close()        time.sleep(0.2)        return lines    def ler_arquivo(self, filename):        f = open(filename)        lines = f.read()        #lines = f.readlines()        #print(f'lendo lines={lines}')        f.close()        time.sleep(0.2)        #f=open("guru99.txt", "r")        #if f.mode == 'r':	    #contents =f.read()        #time.sleep(10)        return lines    def ler_primeira_linha_arquivo(self, filename):        f = open(filename)        lines = f.readlines()        # print(f'lendo lines={lines[0]}')        f.close()        time.sleep(0.2)        # time.sleep(5)        return lines[0].strip('\n')    def salvar_arquivo(self, filename, valor):        with open(filename, 'w+') as f:            f.seek(0)            f.write(valor)            f.close()            time.sleep(0.2)    def sobrescrever_arquivo(self, filename, valor):        #with open(filename, 'w') as f:            #f.seek(0)            #f.write(valor)        with open(filename, 'w') as file:            file.write('{}'.format(valor))            file.close()            time.sleep(0.2)    def recriar_arquivo(self, filename):        f = open(filename, "w+")        f.close()        time.sleep(0.2)    def agregar_arquivo(self, filename, valor):        with open(filename, 'a') as f:            f.write(valor + '\n')            f.close()            time.sleep(0.2)    def agregar_arquivo_sem_quebra(self, filename, valor):        with open(filename, 'a') as f:            f.write(valor)            f.close()            time.sleep(0.2)    def formatar_cpf(self, cpf):        if len(cpf) < 11:            cpf = cpf.zfill(11)        cpf = '{}.{}.{}-{}'.format(cpf[:3], cpf[3:6], cpf[6:9], cpf[9:])        return cpf    def limpar_cpf(self, cpf):        return str(cpf).replace('-','').replace('.','')    def cpf11digits(self, cpf):        return str('{:0>11}'.format(self.somente_numeros(cpf)))   #cpf com 11 digito e somente numeros (deve ser passado como string)    def convert_data_excel_humano(self, excel_data):        #excel_data = 43411 >> 07/11/2018        data_transformada = datetime.fromordinal(datetime(1900, 1, 1).toordinal() + excel_data - 2).date() #tem que ser '-2' por causa de uma contagem maluca do excel        data_formato_humano = str('{:0>2}/{:0>2}/{:0>4}'.format(data_transformada.day,data_transformada.month,data_transformada.year))        #self.logger.info('{} > {} >> {}'.format(excel_data, data_transformada, data_formato_humano))        return data_formato_humano    def line_count(self, fname):        num_lines = 0        with open(fname, 'r', encoding="utf8") as f:            for line in f:                num_lines += 1            f.close()            time.sleep(0.2)        return (num_lines)    def somente_numeros(self, numerossujos):        return re.sub('[^0-9]', '', numerossujos)    def remover_acentos(self, txt):        # https://wiki.python.org.br/RemovedorDeAcentos        return normalize('NFKD', txt).encode('ASCII', 'ignore').decode('ASCII')    # def somente_letras_numeros(self, string):    #     return re.sub('[^a-zA-Z0-9]+', '', string)    def somente_letras_numeros_espaco_ponto(self, string):        return re.sub('[^a-zA-Z0-9. ]+', '', string)    def somente_letras(self, string):        return re.sub('[^a-zA-Z]+', '', string)    #enio 07/08/2019    def removedor_acentuacao(self, string_com_acentos):        #fonte da dica: https://pt.stackoverflow.com/questions/331297/como-remover-acentua%C3%A7%C3%B5es-com-express%C3%B5es-regulares-no-python        #Um modo simples que usa o módulo unicodedata, incluído no python, pra decompor cada acento unicode em seu codepoint original + codepoint de combinação, depois filtrar os codepoints de combinação para ter uma string limpa:        #import unicodedata        #string_com_acentos = "Olá você está????"        string_nova = ''.join(ch for ch in unicodedata.normalize('NFKD', string_com_acentos) if not unicodedata.combining(ch))        #self.logger.info(string_nova)        return f'{string_nova}'    def numero_para_coluna_excel(self,dividendo):        # dividendo L divisor=26        # resto         quociente-1        colunas = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",                   "U", "V", "W", "X", "Y", "Z"]        if dividendo < 702:            if dividendo > 25:                resto = dividendo % 26                quociente = dividendo / 26 - 1                return '{}{}'.format(colunas[int(quociente)], colunas[int(resto)])            else:                return '{}'.format(colunas[dividendo])        else:            return 'null'    def pegar_nome_arquivo(self,diretorio_e_arquivo):        file = diretorio_e_arquivo.strip(' ')        if os.name == 'nt':                    #identifica o tipo de OS, para win=nt            listfiledir=file.split('\\')       #windows        else:            listfiledir=file.split('/')        # linux        filelen = len(listfiledir)         #pega a quantidade de diretorios que tem  no caminho do arquivo usando o separador /(unix) ou \(win)        filename = listfiledir[filelen-1]        return filename    def pegar_caminho_diretorio_do_arquivo(self, diretorio_e_arquivo):        file = diretorio_e_arquivo.strip(' ')        if os.name == 'nt':  # identifica o tipo de OS, para win=nt            listfiledir = file.split('\\')  # windows        else:            listfiledir = file.split('/')  # linux        filelen = len(            listfiledir)  # pega a quantidade de diretorios que tem  no caminho do arquivo usando o separador /(unix) ou \(win)        dirname = self.converte_lista_para_texto(listfiledir[0:filelen - 1], '/')        return dirname    def converte_lista_para_texto(self, lista, separador):        # Converting integer list to string list        list_string = [str(i) for i in lista]        # Join list items using join()        list_string = f"{separador}".join(list_string)        return list_string    # def converte_texto_para_lista(self, texto):    #     lista = f"{texto.split()}"    #     return lista    def mover_arquivo(self,origem,destino):        try:            self.logger.info(f"movendo arquivo original {origem} para novo destino {destino} ")            new_path = shutil.move(origem, destino)            #print(new_path)            self.logger.info(f"movido arquivo com sucesso: {new_path} ")        except Exception as e:            self.logger.error(f"erro ao mover arquivo {e}")            self.logger.error(f"ERRO ao mover arquivo original {origem} para novo destino {destino} - {e}")    def copiar_arquivo(self,origem,destino):        try:            self.logger.info(f"COPIANDO arquivo original {origem} para novo destino {destino} ")            new_path = shutil.copy2(origem, destino)            #print(new_path)            self.logger.info(f"COPIADO arquivo com sucesso: {new_path} ")        except Exception as e:            self.logger.error(f"erro ao copiar arquivo {e}")            self.logger.error(f"ERRO ao copiar arquivo original {origem} para novo destino {destino} - {e}")    def criar_diretorio(self,dirName):        try:            os.makedirs(dirName)            #self.logger.info("Directory ", dirName, " Created ")            self.logger.info(f"Directory {dirName} Created OK")        except FileExistsError:            print('')            #self.logger.warning("Directory ", dirName, " already exists")            self.logger.warning(f"Directory {dirName} already exists")    def limpar_diretorio(self,path):        #path = "diretorio"        dir = os.listdir(path)        os.listdir(path)        #time.sleep(0.2)        print('\n')        for file in dir:            self.logger.info('deletando {}/{}'.format(path,file))            try:                os.remove(path+'/'+file)            except:                self.logger.info('Deletando file {} ---> não encontrado'.format(file))            #if file == "arquivo.txt":            #    os.remove(file)        print('\n')        time.sleep(0.3)    def zipar(self, nome_do_zip, arqs_para_zipar):                               #arqs_para_zipar em forma de lista, parecido com o append do anexos do qlikview e mailler_gmail        fantasy_zip = zipfile.ZipFile('{}'.format(nome_do_zip), 'w')        files = arqs_para_zipar        #files=anexos        qtde_files = len(files)        files_count = 0        while files_count < qtde_files:            file = files[files_count].strip(' ')            if os.name == 'nt':                    #identifica o tipo de OS, para win=nt                listfiledir=file.split('\\')       #windows            else:                listfiledir=file.split('/')            filelen = len(listfiledir)         #pega a quantidade de diretorios que tem  no caminho do arquivo usando o separador /(unix) ou \(win)            filename=listfiledir[filelen-1]            self.logger.info('filename {}'.format(filename))            fantasy_zip.write(file, filename, compress_type=zipfile.ZIP_DEFLATED)            #fantasy_zip.write(file, compress_type=zipfile.ZIP_DEFLATED)            files_count +=1        fantasy_zip.close()        time.sleep(0.2)    def subir_ftp(self, host, username, password, arquivo, dir_destino):        File2Send = arquivo        filename=self.pegar_nome_arquivo(arquivo)        #self.logger.info('File2Send {}'.format(File2Send))        Output_Directory = dir_destino        #self.logger.info('Output_Directory {}'.format(Output_Directory))        tentativas=0        max_tentativas=3        print('\n')        self.logger.info("start ftp")        while tentativas < max_tentativas:            try:                # ftp = FTP(host)                ftp = FTP(host, timeout=600)                #ftp.connect(host='', port=0, timeout=None, source_address=None)                ftp.login(username, password)                #self.logger.info('ftp: {} {} {}'.format(ftp,username,password))                file = open(File2Send, "rb")                file.close()                time.sleep(0.2)                #self.logger.info('file {}'.format(file))                ftp.cwd(Output_Directory)                ftp.storbinary('STOR ' + filename, file)                self.logger.info("STORing File now...")                ftp.quit()                file.close()                time.sleep(0.2)                self.logger.info("File transfered")                tentativas = 100                #status='Sucesso'            except:                self.logger.info("An error occured {}".format(tentativas))                tentativas +=1                #status = 'Erro'                time.sleep(30)            finally:                if tentativas == 3:                    self.logger.info('Tentativa {} falhou. Não foi possivel enviar :(  {} - {}'.format(tentativas, arquivo,host))                    raise Exception("falha em subir arquivo {} para ftp {} - tentativa {}".format(arquivo,host,tentativas))                #time.sleep(10)    def criar_dir_ftp(self, host, username, password, arquivo, dir_destino):        File2Send = arquivo        filename=self.pegar_nome_arquivo(arquivo)        #self.logger.info('File2Send {}'.format(File2Send))        Output_Directory = dir_destino        #self.logger.info('Output_Directory {}'.format(Output_Directory))        tentativas=0        max_tentativas=3        print('\n')        self.logger.info("start ftp")        while tentativas < max_tentativas:            try:                ftp = FTP(host, timeout=600)                ftp.login(username, password)                file = open(File2Send, "rb")                file.close()                time.sleep(0.2)                ftp.cwd(Output_Directory)                ftp.storbinary('STOR ' + filename, file)                self.logger.info("STORing File now...")                ftp.quit()                file.close()                time.sleep(0.2)                self.logger.info("File transfered")                tentativas = 100            except:                self.logger.info("tentativas excedidas{}".format(tentativas))                tentativas +=1                time.sleep(30)            finally:                if tentativas == 3:                    self.logger.info('Tentativa {} falhou. Não foi possivel enviar :(  {} - {}'.format(tentativas, arquivo,host))                    raise Exception("falha em subir arquivo {} para ftp {} - tentativa {}".format(arquivo,host,tentativas))                #time.sleep(10)    def pega_nome_robo(self, nome_robo):        if os.name == 'nt':                    #identifica o tipo de OS, para win=nt            #listfiledir=file.split('\\')       #windows            nome_1ist = nome_robo.split('\\')        else:            #listfiledir=file.split('/')        # linux            nome_1ist = nome_robo.split('/')        #nome_1ist = nome_robo.split('/')        # print(f'pega_nome_robo nome_1ist:{nome_1ist}')        nome_last=len(nome_1ist) - 1        # print(f'pega_nome_robo nome_last:{nome_last}')        nome_list2=nome_1ist[nome_last].split('.')        # print(f'pega_nome_robo nome_list2:{nome_list2}')        nome_last2=nome_list2[0]        # print(f'pega_nome_robo nome_last2:{nome_last2}')        # time.sleep(1)        return '{}'.format(nome_last2)    def duplica_log_robo(self,logging,logger,log_dir,robo_nome):        #self.logger.info('logging {} ,logger {} ,log_dir {} ,robo_nome {}'.format(logging,logger,log_dir,robo_nome))        data_hoje_log = datetime.today().strftime("%Y%m%d")        fh = logging.FileHandler('{}{}_{}.log'.format(log_dir, robo_nome, data_hoje_log))        fh.setLevel(logging.DEBUG)        ch = logging.StreamHandler()        ch.setLevel(logging.ERROR)        formatter = logging.Formatter('%(asctime)s %(name)s: %(levelname)s %(message)s ')        ch.setFormatter(formatter)        fh.setFormatter(formatter)        logger.addHandler(ch)        logger.addHandler(fh)    ###############################################    def escreve_imagem_old(self, arquivo_entrada, arquivo_saida,path_font,font_ttf, size, corR, corG, corB, top, left, texto):        #exemplo de paramentros font:        #font_ttf, size, corR, corG, corB, top, left = 'Roboto-Regular.ttf', 10, 218, 220, 224, 1, 25        #exemplos robo stormtech_002        # self.util.criar_diretorio(self.util.pegar_caminho_diretorio_do_arquivo(f'{arquivo_saida}'))        self.criar_diretorio(self.pegar_caminho_diretorio_do_arquivo(f'{arquivo_saida}'))        #self.logger.info(f'abrindo imagem para editar {arquivo_entrada}')        self.logger.info(f'abrindo imagem para editar {arquivo_entrada}')        #font = ImageFont.truetype(f'{self.path_font}{font_ttf}', size)        font = ImageFont.truetype(f'{path_font}{font_ttf}', size)        img_arquivo_entrada = Image.open(f'{arquivo_entrada}')        draw = ImageDraw.Draw(img_arquivo_entrada)        draw.text((left, top), f'{texto}', (corR, corG, corB), font=font)        # self.logger.info(f'salvando imagem {arquivo_saida}')        self.logger.info(f'salvando imagem {arquivo_saida}')        img_arquivo_entrada.save(f'{arquivo_saida}')        # self.logger.info('\n')        print('\n')    ###############################################    def escreve_imagemV2(self, texto, arquivo, size=25, top=2, left=2, corR=28, corG=28, corB=28, font_ttf='', path_font='', path_tmp='' ):        if f'{path_tmp}' == '':            path_tmp=self.path_tmp        if f'{path_font}' == '':            path_font=self.path_font        if f'{font_ttf}' == '':            font_ttf=self.font_ttf        self.criar_diretorio(path_tmp)        self.escreve_imagem(arquivo,path_tmp,path_font,font_ttf, size, corR, corG, corB, top, left, texto)    def escreve_imagem(self,arquivo,path_tmp,path_font,font_ttf, size, corR, corG, corB, top, left, texto):        nome_saida = self.pegar_nome_arquivo(arquivo)        #exemplo de paramentros font:        #font_ttf, size, corR, corG, corB, top, left = 'Roboto-Regular.ttf', 10, 218, 220, 224, 1, 25        #exemplos robo stormtech_002        # self.util.criar_diretorio(self.util.pegar_caminho_diretorio_do_arquivo(f'{arquivo_saida}'))        self.criar_diretorio(self.pegar_caminho_diretorio_do_arquivo(f'{arquivo}'))        self.criar_diretorio(self.pegar_caminho_diretorio_do_arquivo(f'{path_tmp}'))        # self.logger.info(f'abrindo imagem para editar {arquivo}')        #font = ImageFont.truetype(f'{self.path_font}{font_ttf}', size)        font = ImageFont.truetype(f'{path_font}{font_ttf}', size)        img_arquivo_entrada = Image.open(f'{arquivo}')        draw = ImageDraw.Draw(img_arquivo_entrada)        #PIL.ImageDraw.Draw.text(xy, text, fill=None, font=None, anchor=None, spacing=0, align="left")        # draw.text((left, top), f'{texto}', (corR, corG, corB), font=font, anchor=None, spacing=0, align="right")        draw.text((left, top), f'{texto}', (corR, corG, corB), font=font)        # self.logger.info(f'salvando imagem {path_tmp}{nome_saida}_temp.png')        # self.logger.info(f'salvando imagem {path_tmp}temp{nome_saida}')        # img_arquivo_entrada.save(f'{path_tmp}{nome_saida}_temp.png')        img_arquivo_entrada.save(f'{path_tmp}temp{nome_saida}')        #self.logger.info(f'removendo imagem {arquivo}')        #os.remove(f'{arquivo}')        # self.logger.info(f'movendo imagem {path_tmp}{nome_saida}_temp.png >> {arquivo}')        # self.logger.info(f'movendo imagem {path_tmp}temp{nome_saida} >> {arquivo}')        #print('x1')        # os.rename(f"{path_tmp}{nome_saida}_temp.png", f"{arquivo}")        os.rename(f"{path_tmp}temp{nome_saida}", f"{arquivo}")        #print('x2')        print('\n')        # self.logger.info('\n')    ###############################################    def cortar_imagem(self, arquivo_entrada, arquivo_saida, esquerda, superior, direita, inferior):        self.logger.info(f'arquivo_entrada {arquivo_entrada}, arquivo_saida {arquivo_saida}, esquerda {esquerda}, superior {superior}, direita {direita}, inferior {inferior}')        # exemplos robo stormtech_002        #self.util.criar_diretorio(self.util.pegar_caminho_diretorio_do_arquivo(f'{arquivo_saida}'))        # self.logger.info('cortando 001')        self.criar_diretorio(self.pegar_caminho_diretorio_do_arquivo(f'{arquivo_saida}'))        # self.logger.info('cortando 002')        #self.logger.info(f'recortando imagem {arquivo_entrada}')        self.logger.info(f'recortando imagem {arquivo_entrada}')        # self.logger.info('cortando 003')        img1 = Image.open(f'{arquivo_entrada}')        # self.logger.info('cortando 004')        # esquerda, superior, direita, inferior = 300, 128, 1570, 625        time.sleep(0.3)        cropped_img = img1.crop((esquerda, superior, direita, inferior))        # self.logger.info('cortando 005')        # self.logger.info(f'salvando imagem cortada {arquivo_saida}')        self.logger.info(f'salvando imagem cortada {arquivo_saida}')        time.sleep(0.3)        # self.logger.info('cortando 006')        cropped_img.save(f'{arquivo_saida}')        # self.logger.info('cortando 007')        self.logger.info('\n')        # self.logger.info(f'abrindo imagem para editar {arquivo_entrada}')        # font = ImageFont.truetype(f'{self.path_font}{font_ttf}', size)        # img_arquivo_entrada = Image.open(f'{arquivo_entrada}')        # draw = ImageDraw.Draw(img_arquivo_entrada)        # draw.text((left, top), f'{texto}', (corR, corG, corB), font=font)        # self.logger.info(f'salvando imagem {arquivo_saida}')        # img_arquivo_entrada.save(f'{arquivo_saida}')    ###############################################    #tipo= xpath ou id    def screenshot_elemento(self, tipo, elemento, driver, file_saida, dir_tmp, margem_cima=0,margem_dir=0,margem_baixo=0,margem_esq=0):    #def screenshot_elemento(self, id, driver, file_saida, dir_tmp):        nome_saida=self.pegar_nome_arquivo(file_saida)        # exemplos robo stormtech_002        # https://seleniumwithjavapython.wordpress.com/selenium-with-java/code-snippets/screenshot-of-a-specific-element/        # http://www.software-testing-tutorials-automation.com/2015/01/how-to-capture-element-screenshot-using.html        # https://stackoverflow.com/questions/15510882/selenium-get-coordinates-or-dimensions-of-element-with-python        # https://tutorial.eyehunts.com/python/python-delete-file-remove-multiple-if-exists/        self.logger.info(f'\ntipo: {tipo}')        self.logger.info(f'file_saida: {file_saida}')        self.logger.info(f'dir_tmp: {dir_tmp}')        self.logger.info(f'elemento: {elemento}\n')        if f'{tipo}' == 'id':            self.logger.info(f'\nlocalizando {tipo} elemento: {elemento}')            # imagem=self.driver.find_element_by_xpath("//*[@id='post-22532']/div[1]/div[2]/div/div/p[25]/a/img")            #element = driver.find_element_by_xpath(f'{xpath}')            element = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, f"{elemento}")))        elif f'{tipo}' == 'xpath':            self.logger.info(f'\nlocalizando {tipo} elemento: {elemento}')            # imagem=self.driver.find_element_by_xpath("//*[@id='post-22532']/div[1]/div[2]/div/div/p[25]/a/img")            #element = driver.find_element_by_xpath(f'{elemento}')            element = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.XPATH, f"{elemento}")))            #element = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, f"{id}")))        size_elemento_a=element.size        self.logger.info(f'\n\n\nsize_elemento_a {size_elemento_a}')        #time.sleep(5)        image_width = int(element.size['width']) + margem_dir        image_height = int(element.size['height']) + margem_baixo        location_x = int(element.location['x']) - margem_esq        location_y = int(element.location['y']) - margem_cima        self.logger.info(f'image_width {image_width}')        self.logger.info(f'image_height {image_height}')        self.logger.info(f'location_x {location_x}')        self.logger.info(f'location_y {location_y}')        #time.sleep(0.2)        self.criar_diretorio(dir_tmp)        driver.save_screenshot(f'{dir_tmp}{nome_saida}_temp.png')        #time.sleep(1.0)        self.cortar_imagem(f'{dir_tmp}{nome_saida}_temp.png', f'{file_saida}',location_x,location_y,location_x + image_width,location_y + image_height)        self.logger.info(f'removendo file temp: {dir_tmp}{nome_saida}_temp.png')        time.sleep(0.2)        os.remove(f'{dir_tmp}{nome_saida}_temp.png')    def saindo_driver(self,driver,logger):        self.logger.info('\n\n')        try:            logger.info('Encerrado webdriver! ')            try:                logger.info('saindo quit webdriver')                driver.quit()                logger.info('OK quit webdriver')                time.sleep(0.2)            except Exception as e:                logger.warning(f'saindo quit webdriver {e}')            try:                logger.info('saindo exit webdriver')                driver.exit()                logger.info('OK exit webdriver')                time.sleep(0.2)            except Exception as e:                logger.warning(f'saindo exit webdriver {e}')            try:                logger.info('saindo close webdriver')                driver.close()                logger.info('OK close webdriver')                time.sleep(0.2)            except Exception as e:                logger.warning(f'saindo close webdriver {e}')            try:                logger.info('saindo stop webdriver')                driver.stop()                logger.info('OK stop webdriver')                time.sleep(0.2)            except Exception as e:                logger.warning(f'saindo stop webdriver {e}')            try:                logger.info('saindo dispose webdriver')                driver.dispose()                logger.info('OK dispose webdriver')                time.sleep(0.2)            except Exception as e:                logger.warning(f'saindo dispose webdriver {e}')        except Exception as e:            logger.error(f'ERRO Encerrado webdriver! {e}')            time.sleep(0.2)    ######################################    ########### adicionar novos abaixo com marcação de data e criador:    ######################################    ### enio: 12/08/2019    # def trocacor(self,int(r_in),int(g_in),int(b_in),img_in,int(r_out),int(g_out),int(b_out),img_out):    def trocacor(self,r_in,g_in,b_in,img_in,r_out,g_out,b_out,img_out):        r_in=int(r_in)        g_in=int(g_in)        b_in=int(b_in)        r_out=int(r_out)        g_out=int(g_out)        b_out=int(b_out)        self.logger.info(f'input {r_in},{g_in},{b_in},{img_in}')        self.logger.info(f'ouput {r_out},{g_out},{b_out},{img_out}')        # time.sleep(2.5)        ## alterador de cor de imagem        #parametros de rgb de entrada e saida        #caminho completo do arquivo de entrata e saida        #obs: o arquivo de saida pode ser o mesmo de entrada, assim será sobrescrito a imagem        self.logger.info('im')        im = cv2.imread(f'{img_in}')        #rgb é invertido nessa função: bgr, por isso o [::-1] para inverter as listas, assim podemos passar os parametros rgb de forma normal        ####                 B  G   R                     B   G  R        #im[np.where((im == [255, 135, 0][::-1]).all(axis=2))] = [201, 41, 220][::-1]        self.logger.info('im np')        # im[np.where((im == [r_in, g_in, b_in][::-1]).all(axis=2))] = [r_out, g_out, b_out][::-1]        im[np.where((im == [r_in, g_in, b_in][::-1]).all(axis=2))] = [r_out, g_out, b_out][::-1]        #im[np.where((im == [f'{b_in}', f'{g_in}', f'{r_in}']).all(axis=2))] = [f'{b_out}', f'{g_out}', f'{r_out}']        # im[np.where((im == [255, 135, 0]).all(axis=2))]        = [201, 41, 220]        # im[np.where((im == [255, 135, 0][::-1]).all(axis=2))] = [201, 41, 220][::-1]        self.logger.info('cv2')        # cv2.imwrite(f'{img_out}_tmp', im)        cv2.imwrite(f'{img_out}', im)        # time.sleep(0.2)        # self.logger.info('os rename')        # os.rename(f'{img_out}_tmp', f'{img_out}')        # self.logger.info('os remove')        # time.sleep(0.2)        # os.remove(f"{img_out}_tmp")    ############################################################################    ### enio: 28/08/2019    def num_para_mes(self,mes_num):        num=int(mes_num)        if num == 1:            mes='janeiro'        elif num == 2:            mes='fevereiro'        elif num == 3:            mes='março'        elif num == 4:            mes='abril'        elif num == 5:            mes='maio'        elif num == 6:            mes='junho'        elif num == 7:            mes='julho'        elif num == 8:            mes='agosto'        elif num == 9:            mes='setembro'        elif num == 10:            mes='outubro'        elif num == 11:            mes='novembro'        elif num == 12:            mes='dezembro'        else:            mes=''        return f'{mes}'    ######################################    ######################################    ### enio: 28/08/2019    def dimensoes_de_font_de_texto(self,caminho_da_font,tamanho,string):        # font = ImageFont.truetype('times.ttf', 12)        # size = font.getsize('Hello world')        # print(size)        font = ImageFont.truetype(f'{caminho_da_font}', int(tamanho))        size = font.getsize(f'{string}')        #       (x,y)        self.logger.info(f'x={size[0]}    y={size[1]}')        return size    ######################################    ######################################    ### enio: 28/08/2019    def convert_img_para_pdf(self,imagem,pdf,remove_imagem):        #                                     remove_imagem >> 0 remove imagem,   1 = não remove        # Python3 program to convert image to pfd        # using img2pdf library        # importing necessary libraries        print('# storing image path')        img_path = f"{imagem}"        print('# storing pdf path ')        pdf_path = f"{pdf}"        print('# opening image ')        image = Image.open(img_path)        print('# converting into chunks using img2pdf')        pdf_bytes = img2pdf.convert(image.filename)        print('# opening or creating pdf file ')        file = open(pdf_path, "wb")        print('# writing pdf files with chunks')        file.write(pdf_bytes)        print('# closing image file ')        image.close()        time.sleep(0.2)        print('# closing pdf file ')        file.close()        time.sleep(0.2)        # output        print("Successfully made pdf file")        if remove_imagem == 0:            print("removendo imagem")            time.sleep(0.3)            os.remove(f'{img_path}')        else:            print("não remove imagem")    ############################################################################    ### enio: 09/04/2020    def sort_arquivo_e_sobrescreve(self,fname):        self.logger.info('\n')        try:            self.logger.info(f'sort_arquivo_e_sobrescreve1 abrindo: {fname}')            list_fname=[]            temp_fname=f'{fname}.01.tmp'            self.logger.info(f'sort_arquivo_e_sobrescreve2 lendo: {fname}')            with open(fname, 'r', encoding="utf8") as f:                for line in f:                    list_fname.append(f'{line}')                f.close()                time.sleep(0.2)            self.logger.info(f'sort_arquivo_e_sobrescreve3 ordenado: {fname}')            comp_list=len(list_fname)            count_comp_list = 0            list_fname.sort()            self.logger.info(f'sort_arquivo_e_sobrescreve4 escrevendo temp: {fname}')            while count_comp_list < comp_list:                self.agregar_arquivo(temp_fname,list_fname[count_comp_list])                count_comp_list += 1            self.logger.info(f'sort_arquivo_e_sobrescreve5 sobrescrevendo original: {fname}')            leitura_temp_fname=self.ler_arquivo(temp_fname)            self.sobrescrever_arquivo(fname,leitura_temp_fname)            self.logger.info(f'sort_arquivo_e_sobrescreve6 apangando temp: {fname}')            os.remove(temp_fname)        except Exception as e:            self.logger.info(f'sort_arquivo_e_sobrescreve7 {fname} ERRO: {e}' )        self.logger.info('\n')    ######################################    def uniq_arquivo_sobrescreve(self,fname):        self.logger.info('\n')        #mylist = ["d", "b", "a", "c", "c", "a", "a", "c", "c", "d", "d"]        #mylist = list(dict.fromkeys(mylist))        #print(mylist)        try:            self.logger.info(f'uniq_arquivo_sobrescreve1 abrindo: {fname}')            list_fname=[]            temp_fname=f'{fname}.02.tmp'            self.logger.info(f'uniq_arquivo_sobrescreve2 lendo: {fname}')            with open(fname, 'r', encoding="utf8") as f:                for line in f:                    print(f'line={line}')                    list_fname.append(f'{line}')                    print(f'list_fname={list_fname}')                    print('--\n--')                    #time.sleep(5)                f.close()                time.sleep(0.2)            self.logger.info(f'uniq_arquivo_sobrescreve3 remove duplos e mantem ordem da primeira aparição: {fname}')            list_fname = list(dict.fromkeys(list_fname))            #            #comp_list=len(list_fname_temp)            comp_list=len(list_fname)            count_comp_list = 0            #list_fname.sort()            self.logger.info(f'uniq_arquivo_sobrescreve4 escrevendo temp: {fname} - comp_list{comp_list} - count_comp_list{count_comp_list}')            while count_comp_list < comp_list:                # self.agregar_arquivo(temp_fname,list_fname[count_comp_list])                self.agregar_arquivo_sem_quebra(temp_fname,list_fname[count_comp_list])                count_comp_list += 1            self.logger.info(f'uniq_arquivo_sobrescreve6 sobrescrevendo original: {fname} - comp_list{comp_list} - count_comp_list{count_comp_list}')            leitura_temp_fname=self.ler_arquivo(temp_fname)            self.sobrescrever_arquivo(fname,leitura_temp_fname)            self.logger.info(f'uniq_arquivo_sobrescreve7 apangando temp: {fname}')            os.remove(temp_fname)        except Exception as e:            self.logger.info(f'uniq_arquivo_sobrescreve8 {fname} ERRO: {e}' )        self.logger.info('\n\n\n')        #time.sleep(10)    ######################################    def convert_image_to_base64(self, imagem):        try:            self.logger.debug(f'abrindo imagem {imagem} para extrair o base64')            with open(imagem, "rb") as img_file:                my_string = base64.b64encode(img_file.read())                img_file.close()                time.sleep(0.2)            #print(my_string)            #print(my_string.decode('utf-8'))            return '{}'.format(my_string.decode('utf-8'))        except Exception as e:            self.logger.error(f'ERRO abrir imagem {imagem} para extrair o base64: {e}')            return ''    def recaptcha_V2(self, url_website, key_id_website):        retorno= 'ERROR: vazio'        try:            config = self.get_config()            chave = config['anticapcha']['chave']            retorno = ''            solver = recaptchaV2Proxyless()            solver.set_verbose(1)            solver.set_key(f'{chave}')            solver.set_website_url(f'{url_website}')            solver.set_website_key(f'{key_id_website}')            g_response = solver.solve_and_return_solution(self.logger)            if g_response != 0:                self.logger.info(f'g-response: g_response={g_response}')                retorno=g_response            else:                self.logger.error(f'task finished with error solver.error_code={solver.error_code}')                retorno = f'ERROR: {solver.error_code}'        except Exception as e:            msg=f'ERRO ao extrair texto do recaptcha url_website="{url_website}" - key_id_website="{key_id_website} - erro:{e}'            self.logger.error(f'{msg}')            retorno = f'ERROR: desconhecido: {msg}'.replace('\n',' ').strip('\n').strip(' ')        return retorno    ############################################    def extrai_texto_captcha(self, caminho_da_imagem):        #fonte: https://anti-captcha.com/apidoc/image        try:            config = self.get_config()            retorno = ''            solver = imagecaptcha()            solver.set_verbose(1)            #solver.set_key("b2f7941460fdb717dd4477e4e24804bb")            chave=config['anticapcha']['chave']            solver.set_key(f'{chave}')            self.logger.info(f'indianos começando a digitar o captcha')            captcha_text = solver.solve_and_return_solution(caminho_da_imagem)            if captcha_text != 0:                self.logger.info(f'recebendo resultado captcha_text={captcha_text}')                retorno=captcha_text            else:                self.logger.error(f'{self.usuario}: {self.complemento_url}:ERRO no resultado captcha_text={captcha_text} - solver.error_code={solver.error_code}')  # print  # "task finished with error " + solver.error_code                retorno = f'{captcha_text};{caminho_da_imagem};ERROR:{solver.error_code}'.replace('\n',' ').strip('\n').strip(' ')        except Exception as e:            self.logger.error(f'ERRO ao extrair texto do captcha da imagem {caminho_da_imagem} - erro:{e}')            retorno = f'ERRO desconhecido {caminho_da_imagem}: {e}'.replace('\n',' ').strip('\n').strip(' ')        return retorno    ############################################    def remove_linhas_duplicadas_de_uma_coluna(self, dataframe, titulo_da_coluna):        print('')        try:            df1 = dataframe            qtde_linhas_df1_a = len(df1.index)            # usuario = f''            # df1 = pd.read_excel(f'/home/enio/Downloads/1.xls', 'Propostas')            self.logger.debug(f': remove duplos da coluna {titulo_da_coluna}: INI')            # qtde_linhas_df1_a = len(df1.index)            self.logger.debug(f': remove duplos da coluna {titulo_da_coluna}: qtde_linhas_df1_a={qtde_linhas_df1_a} ')            if qtde_linhas_df1_a > 0:                dict_df1_index_prop = {}                qtde_linhas_df_index_prop = qtde_linhas_df1_a                while qtde_linhas_df_index_prop > 0:                    self.logger.debug(f': qtde_linhas_df_index_prop={qtde_linhas_df_index_prop} ')  # fez até aqui                    index_da_vez = qtde_linhas_df_index_prop - 1                    self.logger.debug(f': index_da_vez={index_da_vez} ')                    #proposta_do_index_da_vez = df1["PROPOSTA"][index_da_vez]                    proposta_do_index_da_vez = df1[f"{titulo_da_coluna}"][index_da_vez]                    self.logger.debug(f': proposta_do_index_da_vez={proposta_do_index_da_vez} ')                    dict_df1_index_prop.update({f'{index_da_vez}': f'{proposta_do_index_da_vez}'})                    self.logger.debug(f': remove duplos da coluna {titulo_da_coluna} {dict_df1_index_prop}')                    qtde_linhas_df_index_prop -= 1                qtde_linhas_df_dict_index = qtde_linhas_df1_a                while qtde_linhas_df_dict_index > 0:                    self.logger.debug(f': INI qtde_linhas_df_dict_index={qtde_linhas_df_dict_index} ')                    indice_dict_da_vez = qtde_linhas_df_dict_index - 1                    prop_dict_da_vez = dict_df1_index_prop[f'{indice_dict_da_vez}']                    self.logger.debug(f': remove duplos da coluna {titulo_da_coluna}: proposta da posicao {indice_dict_da_vez} >>> {prop_dict_da_vez}')                    counter_loop_dict = qtde_linhas_df1_a                    while counter_loop_dict > 0:                        self.logger.debug(f': counter_loop_dict={counter_loop_dict} ')                        # indice_counter_loop_dict = counter_loop_dict - 1                        indice_counter_loop_dict = counter_loop_dict - 1                        try:                            self.logger.debug(f': remove duplos da coluna {titulo_da_coluna}: tentando comparar {prop_dict_da_vez} == {df1[f"{titulo_da_coluna}"][indice_counter_loop_dict]}')                            if f'{prop_dict_da_vez}' == f'{df1[f"{titulo_da_coluna}"][indice_counter_loop_dict]}':                                # if indice_counter_loop_dict != indice_dict_da_vez:                                self.logger.debug(f': propostas sao iguais {prop_dict_da_vez} == {df1[f"{titulo_da_coluna}"][indice_counter_loop_dict]}')                                if indice_counter_loop_dict != indice_dict_da_vez:                                    # if f'{prop_dict_da_vez}' == f'{df1["PROPOSTA"][indice_counter_loop_dict]}':                                    self.logger.debug(f': remove duplos da colun {titulo_da_coluna}: INICIO sucesso  INDICES diferentes: remove: indiceREFdavez:({indice_dict_da_vez}){prop_dict_da_vez} >> indiceremovido:({indice_counter_loop_dict}){prop_dict_da_vez}')                                    # df1.drop(indice_counter_loop_dict)                                    df1.drop(indice_dict_da_vez)                                    self.logger.debug(f': {df1}')                                    # df1 = df1.drop(indice_counter_loop_dict)                                    df1 = df1.drop(indice_dict_da_vez)                                    self.logger.debug(f': FIM sucesso  INDICES diferentes: remove: indiceREFdavez:({indice_dict_da_vez}){prop_dict_da_vez} >> indiceremovido:({indice_counter_loop_dict}){prop_dict_da_vez}\n\n')                                else:                                    self.logger.debug(f': remove duplos da colun {titulo_da_coluna}: INDICES iguais: entao Não REmove remove')                        except Exception as e:                            self.logger.debug(f': Deu erro: não existe o indice no dataframe: {e}\n')                        counter_loop_dict -= 1                    self.logger.debug(f': remove duplos da coluna {titulo_da_coluna}: FIM qtde_linhas_df_dict_index={qtde_linhas_df_dict_index}\n\n--------\n\n ')                    qtde_linhas_df_dict_index -= 1            self.logger.debug(f': remove duplos da coluna {titulo_da_coluna}: FIM')            # df1.to_excel(f'/home/enio/Downloads/2B.xls', index=False, sheet_name='Propostas')        except Exception as e:            self.logger.error(f': ERRO remove duplos PROPOSTA: {e}')        return df1    # def remove_repetidos_lista(lista):    #     l = []    #     for i in lista:    #         if i not in l:    #             l.append(i)    #     l.sort()    #     return l    def Thread_screenshot_driver(self,driver,dir,nome,intervalo=1):        self.logger.error(f'iniciando Thread_screenshot_driver')        loop=0        self.criar_diretorio(dir)        while loop == 0:            Thread(target=self.screenshot_driver, args=[driver,dir,nome]).start()            time.sleep(intervalo)            try:                testa_html = driver.find_elements_by_xpath('//html')            except Exception as e:                loop=1                self.logger.error(f'Erro no Thread_screenshot_driver: {e}')                time.sleep(10)    def screenshot_driver(self,driver,dir,nome):        try:            data_print1 = datetime.today().strftime("%Y/%m/%d %H:%M:%S.%f")            data_print = f'{data_print1}'.replace('/','').replace(' ','').replace(':','')            # self.logger.info(f'screenshot {dir}/{nome}_{data_print}.png')            driver.save_screenshot(f'{dir}/{nome}_{data_print}.png')            self.escreve_imagemV2(f'{nome} {data_print1}',f'{dir}/{nome}_{data_print}.png')        except Exception as e:            self.logger.error(f'Erro no screenshot: {dir}/{nome}_{data_print}.png {e}')    def somente_emails(self,string_emails_baguncados):        self.logger.debug(f'lendo emails: {string_emails_baguncados}')        match = re.findall(r'[\w\.-]+@[\w\.-]+', string_emails_baguncados)        emails_organizados=self.converte_lista_para_texto(match,',').strip(',')        return emails_organizados    def XXXXwait_for_downloads(self, dir_downloadx=None, timemax=300):        dir_download=os.path.abspath(f'{dir_downloadx}')        self.logger.debug("Waiting for downloads", end="")        while any([ filename.endswith(".crdownload") for filename in os.listdir(f'{dir_download}')] ):            time.sleep(1)            self.logger.debug(".", end="")        self.logger.info("done!")    def wait_for_downloads(self, dir_downloadx=None, timemax=300):        download_path=os.path.abspath(f'{dir_downloadx}')        max_delay = timemax        interval_delay = 1        total_delay = 0        file = ''        done = False        while not done and total_delay < max_delay:            files = [f for f in os.listdir(download_path) if f.endswith('.crdownload')]            if not files and len(file) > 1:                done = True                max_delay=0            if files:                file = files[0]            time.sleep(interval_delay)            total_delay += interval_delay            print(f'loop: {total_delay}')        if done:            self.logger.info(f'File(s) [{file}] downloaded in {total_delay} seconds')        if not done:            self.logger.error("File(s) couldn't be downloaded")        return download_path + '/' + file.replace(".crdownload", "")